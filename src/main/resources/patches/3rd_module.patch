Subject: [PATCH] 3rd module
---
Index: src/main/java/course/concurrency/m3_shared/threadLocal/TL_example3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example3.java b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example3.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example3.java	(date 1681219100000)
@@ -0,0 +1,25 @@
+package course.concurrency.m3_shared.threadLocal;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class TL_example3 {
+
+    public static class Task implements Runnable {
+        private final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);
+
+        @Override
+        public void run() {
+            Integer currentValue = value.get();
+            value.set(currentValue + 1);
+            System.out.print(value.get());
+        }
+    }
+
+    public static void main(String[] args) {
+        ExecutorService executor = Executors.newFixedThreadPool(5);
+        for (int i = 0; i < 10; i++) {
+            executor.submit(new Task());
+        }
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/threadLocal/TL_example2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example2.java b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example2.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example2.java	(date 1681219100000)
@@ -0,0 +1,25 @@
+package course.concurrency.m3_shared.threadLocal;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class TL_example2 {
+
+    public static class Task implements Runnable {
+        private static final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);
+
+        @Override
+        public void run() {
+            Integer currentValue = value.get();
+            value.set(currentValue + 1);
+            System.out.print(value.get());
+        }
+    }
+
+    public static void main(String[] args) {
+        ExecutorService executor = Executors.newFixedThreadPool(5);
+        for (int i = 0; i < 10; i++) {
+            executor.submit(new Task());
+        }
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/threadLocal/TL_example5.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example5.java b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example5.java
new file mode 100644
--- /dev/null	(date 1681219102000)
+++ b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example5.java	(date 1681219102000)
@@ -0,0 +1,26 @@
+package course.concurrency.m3_shared.threadLocal;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class TL_example5 {
+
+    public static class Task implements Runnable {
+        private final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);
+
+        @Override
+        public void run() {
+            Integer currentValue = value.get();
+            value.set(currentValue + 1);
+            System.out.print(value.get());
+        }
+    }
+
+    public static void main(String[] args) {
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        for (int i = 0; i < 5; i++) {
+            executor.submit(new Task());
+        }
+    }
+
+}
Index: src/main/java/course/concurrency/m3_shared/threadLocal/TL_example1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example1.java b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example1.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example1.java	(date 1681219100000)
@@ -0,0 +1,23 @@
+package course.concurrency.m3_shared.threadLocal;
+
+public class TL_example1 {
+
+    public static class Task implements Runnable {
+        private static final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);
+
+        @Override
+        public void run() {
+            Integer currentValue = value.get();
+            value.set(currentValue + 1);
+            System.out.print(value.get() + " ");
+        }
+    }
+
+    public static void main(String[] args) {
+        Task task1 = new Task();
+
+        new Thread(task1).start();
+        new Thread(task1).start();
+        new Thread(task1).start();
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/threadLocal/TL_example4.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example4.java b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example4.java
new file mode 100644
--- /dev/null	(date 1681219102000)
+++ b/src/main/java/course/concurrency/m3_shared/threadLocal/TL_example4.java	(date 1681219102000)
@@ -0,0 +1,26 @@
+package course.concurrency.m3_shared.threadLocal;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class TL_example4 {
+
+    public static class Task implements Runnable {
+        private static final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);
+
+        @Override
+        public void run() {
+            Integer currentValue = value.get();
+            value.set(currentValue + 1);
+            System.out.print(value.get());
+        }
+    }
+
+    public static void main(String[] args) {
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        for (int i = 0; i < 5; i++) {
+            executor.submit(new Task());
+        }
+    }
+
+}
Index: src/main/java/course/concurrency/exams/auction/Bid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/Bid.java b/src/main/java/course/concurrency/exams/auction/Bid.java
new file mode 100644
--- /dev/null	(date 1683635158000)
+++ b/src/main/java/course/concurrency/exams/auction/Bid.java	(date 1683635158000)
@@ -0,0 +1,25 @@
+package course.concurrency.exams.auction;
+
+public class Bid {
+    private Long id;
+    private Long participantId;
+    private Long price;
+
+    public Bid(Long id, Long participantId, Long price) {
+        this.id = id;
+        this.participantId = participantId;
+        this.price = price;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public Long getParticipantId() {
+        return participantId;
+    }
+
+    public Long getPrice() {
+        return price;
+    }
+}
Index: src/main/java/course/concurrency/exams/auction/AuctionPessimistic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/AuctionPessimistic.java b/src/main/java/course/concurrency/exams/auction/AuctionPessimistic.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/exams/auction/AuctionPessimistic.java	(date 1681219100000)
@@ -0,0 +1,25 @@
+package course.concurrency.exams.auction;
+
+public class AuctionPessimistic implements Auction {
+
+    private Notifier notifier;
+
+    public AuctionPessimistic(Notifier notifier) {
+        this.notifier = notifier;
+    }
+
+    private Bid latestBid;
+
+    public boolean propose(Bid bid) {
+        if (bid.getPrice() > latestBid.getPrice()) {
+            notifier.sendOutdatedMessage(latestBid);
+            latestBid = bid;
+            return true;
+        }
+        return false;
+    }
+
+    public Bid getLatestBid() {
+        return latestBid;
+    }
+}
Index: src/main/java/course/concurrency/exams/auction/AuctionOptimistic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/AuctionOptimistic.java b/src/main/java/course/concurrency/exams/auction/AuctionOptimistic.java
new file mode 100644
--- /dev/null	(date 1697389751985)
+++ b/src/main/java/course/concurrency/exams/auction/AuctionOptimistic.java	(date 1697389751985)
@@ -0,0 +1,25 @@
+package course.concurrency.exams.auction;
+
+public class AuctionOptimistic implements Auction {
+
+    private Notifier notifier;
+
+    public AuctionOptimistic(Notifier notifier) {
+        this.notifier = notifier;
+    }
+
+    private Bid latestBid;
+
+    public boolean propose(Bid bid) {
+        if (bid.getPrice() > latestBid.getPrice()) {
+            notifier.sendOutdatedMessage(latestBid);
+            latestBid = bid;
+            return true;
+        }
+        return false;
+    }
+
+    public Bid getLatestBid() {
+        return latestBid;
+    }
+}
Index: src/main/java/course/concurrency/exams/auction/AuctionStoppableOptimistic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/AuctionStoppableOptimistic.java b/src/main/java/course/concurrency/exams/auction/AuctionStoppableOptimistic.java
new file mode 100644
--- /dev/null	(date 1697389404971)
+++ b/src/main/java/course/concurrency/exams/auction/AuctionStoppableOptimistic.java	(date 1697389404971)
@@ -0,0 +1,29 @@
+package course.concurrency.exams.auction;
+
+public class AuctionStoppableOptimistic implements AuctionStoppable {
+
+    private Notifier notifier;
+
+    public AuctionStoppableOptimistic(Notifier notifier) {
+        this.notifier = notifier;
+    }
+
+    private Bid latestBid;
+
+    public boolean propose(Bid bid) {
+        if (bid.getPrice() > latestBid.getPrice()) {
+            notifier.sendOutdatedMessage(latestBid);
+            latestBid = bid;
+            return true;
+        }
+        return false;
+    }
+
+    public Bid getLatestBid() {
+        return latestBid;
+    }
+
+    public Bid stopAuction() {
+        return latestBid;
+    }
+}
Index: src/main/java/course/concurrency/exams/auction/Auction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/Auction.java b/src/main/java/course/concurrency/exams/auction/Auction.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/exams/auction/Auction.java	(date 1681219100000)
@@ -0,0 +1,8 @@
+package course.concurrency.exams.auction;
+
+public interface Auction {
+
+    boolean propose(Bid bid);
+
+    Bid getLatestBid();
+}
Index: src/main/java/course/concurrency/exams/auction/AuctionStoppable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/AuctionStoppable.java b/src/main/java/course/concurrency/exams/auction/AuctionStoppable.java
new file mode 100644
--- /dev/null	(date 1697389404950)
+++ b/src/main/java/course/concurrency/exams/auction/AuctionStoppable.java	(date 1697389404950)
@@ -0,0 +1,7 @@
+package course.concurrency.exams.auction;
+
+public interface AuctionStoppable extends Auction {
+
+    // stop auction and return latest bid
+    Bid stopAuction();
+}
Index: src/main/java/course/concurrency/exams/auction/AuctionStoppablePessimistic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/AuctionStoppablePessimistic.java b/src/main/java/course/concurrency/exams/auction/AuctionStoppablePessimistic.java
new file mode 100644
--- /dev/null	(date 1697389404977)
+++ b/src/main/java/course/concurrency/exams/auction/AuctionStoppablePessimistic.java	(date 1697389404977)
@@ -0,0 +1,29 @@
+package course.concurrency.exams.auction;
+
+public class AuctionStoppablePessimistic implements AuctionStoppable {
+
+    private Notifier notifier;
+
+    public AuctionStoppablePessimistic(Notifier notifier) {
+        this.notifier = notifier;
+    }
+
+    private Bid latestBid;
+
+    public boolean propose(Bid bid) {
+        if (bid.getPrice() > latestBid.getPrice()) {
+            notifier.sendOutdatedMessage(latestBid);
+            latestBid = bid;
+            return true;
+        }
+        return false;
+    }
+
+    public Bid getLatestBid() {
+        return latestBid;
+    }
+
+    public Bid stopAuction() {
+        return latestBid;
+    }
+}
Index: src/main/java/course/concurrency/exams/auction/Notifier.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/auction/Notifier.java b/src/main/java/course/concurrency/exams/auction/Notifier.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/exams/auction/Notifier.java	(date 1681219100000)
@@ -0,0 +1,16 @@
+package course.concurrency.exams.auction;
+
+public class Notifier {
+
+    public void sendOutdatedMessage(Bid bid) {
+        imitateSending();
+    }
+
+    private void imitateSending() {
+        try {
+            Thread.sleep(2000);
+        } catch (InterruptedException e) {}
+    }
+
+    public void shutdown() {}
+}
Index: src/test/java/course/concurrency/exams/auction/ExecutionStatistics.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/course/concurrency/exams/auction/ExecutionStatistics.java b/src/test/java/course/concurrency/exams/auction/ExecutionStatistics.java
new file mode 100644
--- /dev/null	(date 1681219102000)
+++ b/src/test/java/course/concurrency/exams/auction/ExecutionStatistics.java	(date 1681219102000)
@@ -0,0 +1,27 @@
+package course.concurrency.exams.auction;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.LongSummaryStatistics;
+import java.util.concurrent.ConcurrentHashMap;
+
+import static java.util.stream.Collectors.summarizingLong;
+
+public class ExecutionStatistics {
+
+    private ConcurrentHashMap<String, List<Long>> stat = new ConcurrentHashMap<>();
+
+    public void addData(String method, Long duration) {
+        stat.putIfAbsent(method, new ArrayList<>());
+        stat.get(method).add(duration);
+    }
+
+    public void printStatistics() {
+        stat.forEach((k,v) -> System.out.println(k + ": " + listToStat(v)));
+    }
+
+    private String listToStat(List<Long> values) {
+        LongSummaryStatistics stat = values.stream().collect(summarizingLong(Long::valueOf));
+        return String.format("%.0f (%d-%d)", stat.getAverage(), stat.getMin(), stat.getMax());
+    }
+}
Index: src/test/java/course/concurrency/exams/auction/AuctionStoppableTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/course/concurrency/exams/auction/AuctionStoppableTests.java b/src/test/java/course/concurrency/exams/auction/AuctionStoppableTests.java
new file mode 100644
--- /dev/null	(date 1697391994744)
+++ b/src/test/java/course/concurrency/exams/auction/AuctionStoppableTests.java	(date 1697391994744)
@@ -0,0 +1,213 @@
+package course.concurrency.exams.auction;
+
+import org.junit.jupiter.api.*;
+import org.junit.platform.suite.api.IncludeTags;
+import org.junit.platform.suite.api.SelectPackages;
+import org.junit.platform.suite.api.Suite;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class AuctionStoppableTests {
+
+    @Suite
+    @IncludeTags("pessimistic_stoppable")
+    @SelectPackages("course.concurrency.exams.auction")
+    public static class PessimisticSuite {}
+
+    @Suite
+    @IncludeTags("optimistic_stoppable")
+    @SelectPackages("course.concurrency.exams.auction")
+    public static class OptimisticSuite {}
+
+    private static final int TEST_COUNT = 10;
+    private static final ExecutionStatistics stat = new ExecutionStatistics();
+
+    private static final int iterations = 1_000_000;
+    private static final int poolSize = Runtime.getRuntime().availableProcessors();
+
+    private Notifier notifier;
+
+    private AuctionStoppable pessimistic;
+    private AuctionStoppable optimistic;
+
+    // for stopAuction test
+    private Supplier<AuctionStoppable> pessimisticSupplier;
+    private Supplier<AuctionStoppable> optimisticSupplier;
+
+    @BeforeEach
+    public void setup() {
+        notifier = new Notifier();
+
+        pessimisticSupplier = () -> new AuctionStoppablePessimistic(notifier);
+        pessimistic = pessimisticSupplier.get();
+
+        optimisticSupplier = () -> new AuctionStoppableOptimistic(notifier);
+        optimistic = optimisticSupplier.get();
+    }
+
+    @AfterEach
+    public void tearDown() {
+        notifier.shutdown();
+    }
+
+    @AfterAll
+    public static void printStat() {
+        stat.printStatistics();
+    }
+
+    @RepeatedTest(TEST_COUNT)
+    @DisplayName("Pessimistic: load test")
+    @Tag("pessimistic_stoppable")
+    public void testPessimistic() throws InterruptedException {
+        loadTest(pessimistic, "pessimistic");
+    }
+
+    @RepeatedTest(TEST_COUNT)
+    @DisplayName("Optimistic: load test")
+    @Tag("optimistic_stoppable")
+    public void testOptimistic() throws InterruptedException {
+        loadTest(optimistic, "optimistic");
+    }
+
+    public void loadTest(AuctionStoppable auction, String tag) throws InterruptedException {
+        CountDownLatch latch = new CountDownLatch(1);
+        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
+
+        BlockingQueue<Bid> bidQueue = new LinkedBlockingQueue<>();
+        Bid latestBid = null;
+        for (long i = 0; i < iterations*poolSize/3; i++) {
+            bidQueue.offer(new Bid(i-1, i-1, i-1));
+            bidQueue.offer(new Bid(i, i, i));
+            latestBid = new Bid(i+1, i+1, i+1);
+            bidQueue.offer(latestBid);
+        }
+
+        for (int i = 0; i < poolSize; i++) {
+            executor.submit(() -> {
+                try {
+                    latch.await();
+                } catch (InterruptedException ignored) {}
+
+                for (int it = 0; it < iterations; it++) {
+                    Bid bid = bidQueue.poll();
+                    auction.propose(bid);
+                    if (it % 5 == 0) {
+                        auction.getLatestBid();
+                    }
+                }
+            });
+        }
+
+        long start = System.currentTimeMillis();
+        latch.countDown();
+        executor.shutdown();
+        executor.awaitTermination(10, TimeUnit.SECONDS);
+        long end = System.currentTimeMillis();
+
+        assertEquals(latestBid.getPrice(), auction.getLatestBid().getPrice());
+        stat.addData(tag,end - start);
+    }
+
+    @Test
+    @DisplayName("Pessimistic: stopAuction() test")
+    @Tag("pessimistic_stoppable")
+    public void shouldStopAuctionPessimistic() {
+        testStoppedAuction(pessimistic);
+    }
+
+    @Test
+    @DisplayName("Optimistic: stopAuction() test")
+    @Tag("optimistic_stoppable")
+    public void shouldStopAuction() {
+        testStoppedAuction(optimistic);
+    }
+
+    public void testStoppedAuction(AuctionStoppable auction) {
+        Bid expectedBid = new Bid(5L, 5L, 5L);
+
+        boolean isOk = auction.propose(expectedBid);
+        Bid latestBid = auction.getLatestBid();
+
+        assertTrue(isOk, "Auction doesn't perform on single operation");
+        assertEquals(expectedBid, latestBid);
+
+        Bid latestAfterStop = auction.stopAuction();
+        assertEquals(expectedBid, latestAfterStop, "Latest bid is not correct");
+
+        boolean resAfterStop = auction.propose(new Bid(100l, 100l,  100l));
+        assertFalse(resAfterStop, "Bids should not be accepted after stop");
+        latestAfterStop = auction.stopAuction();
+        assertEquals(expectedBid, latestAfterStop, "Latest bid is not correct");
+    }
+
+    @Test
+    @DisplayName("Pessimistic: stopAuction works with data races")
+    @Tag("pessimistic_stoppable")
+    @Timeout(60)
+    public void stopWithDataRacesPessimistic() throws InterruptedException {
+        stopAuctionWithDataRaces(() -> pessimistic);
+    }
+
+    @Test
+    @DisplayName("Optimistic: stopAuction works with data races")
+    @Tag("optimistic_stoppable")
+    @Timeout(60)
+    public void stopWithDataRacesOptimistic() throws InterruptedException {
+        stopAuctionWithDataRaces(() -> optimistic);
+    }
+
+    public void stopAuctionWithDataRaces(Supplier<AuctionStoppable> auctionSuppler) throws InterruptedException {
+        ExecutorService executor = Executors.newFixedThreadPool(2);
+
+        final AtomicReference<Bid> stoppedBid = new AtomicReference<>();
+        Bid firstBid = new Bid(1L, 1L, 1L);
+
+        Bid slow = new Bid(2l, 2l, 2l) {
+            public Long getPrice() {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+                return super.getPrice();
+            }
+        };
+
+        for (int i = 2; i < 100; i++) {
+            AuctionStoppable auction = auctionSuppler.get();
+            auction.propose(firstBid);
+            stoppedBid.set(null);
+            Bid raceBid = slow;
+
+            CountDownLatch startAuctionTasksLatch = new CountDownLatch(1);
+            CountDownLatch auctionTasksDoneLatch = new CountDownLatch(2);
+
+            executor.submit(() -> {
+                try {
+                    startAuctionTasksLatch.await();
+                } catch (InterruptedException ignored) {}
+                auction.propose(raceBid);
+                auctionTasksDoneLatch.countDown();
+            });
+            executor.submit(() -> {
+                try {
+                    startAuctionTasksLatch.await();
+                } catch (InterruptedException ignored) {}
+                Bid stopped = auction.stopAuction();
+                stoppedBid.set(stopped);
+                auctionTasksDoneLatch.countDown();
+            });
+            startAuctionTasksLatch.countDown();
+            auctionTasksDoneLatch.await();
+
+            Long latestPrice = auction.getLatestBid().getPrice();
+            assertEquals(stoppedBid.get().getPrice(), latestPrice, "Bid was updated after stop");
+        }
+
+        executor.shutdownNow();
+    }
+}
Index: src/test/java/course/concurrency/exams/auction/AuctionTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/course/concurrency/exams/auction/AuctionTests.java b/src/test/java/course/concurrency/exams/auction/AuctionTests.java
new file mode 100644
--- /dev/null	(date 1697391146807)
+++ b/src/test/java/course/concurrency/exams/auction/AuctionTests.java	(date 1697391146807)
@@ -0,0 +1,156 @@
+package course.concurrency.exams.auction;
+
+import org.junit.jupiter.api.*;
+import org.junit.platform.suite.api.IncludeTags;
+import org.junit.platform.suite.api.SelectPackages;
+import org.junit.platform.suite.api.Suite;
+
+import java.util.concurrent.*;
+import java.util.stream.LongStream;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class AuctionTests {
+
+    @Suite
+    @IncludeTags("pessimistic")
+    @SelectPackages("course.concurrency.exams.auction")
+    public static class PessimisticSuite {}
+
+    @Suite
+    @IncludeTags("optimistic")
+    @SelectPackages("course.concurrency.exams.auction")
+    public static class OptimisticSuite {}
+
+    private static final int TEST_COUNT = 10;
+    private static final ExecutionStatistics stat = new ExecutionStatistics();
+
+    private static final int iterations = 1_000_000;
+    private static final int poolSize = Runtime.getRuntime().availableProcessors();
+    private static final int bidCount = iterations * poolSize;
+    private Notifier notifier;
+    private Auction pessimistic;
+    private Auction optimistic;
+
+    @BeforeEach
+    public void setup() {
+        notifier = new Notifier();
+        pessimistic = new AuctionPessimistic(notifier);
+        optimistic = new AuctionOptimistic(notifier);
+    }
+
+    @AfterEach
+    public void tearDown() {
+        notifier.shutdown();
+    }
+
+    @AfterAll
+    public static void printStat() {
+        stat.printStatistics();
+    }
+
+    @RepeatedTest(TEST_COUNT)
+    @DisplayName("Optimistic: load test")
+    @Tag("optimistic")
+    public void testOptimisticUnderLoad() throws InterruptedException {
+        loadTest(optimistic, "optimistic");
+    }
+
+    @RepeatedTest(TEST_COUNT)
+    @DisplayName("Pessimistic: load test")
+    @Tag("pessimistic")
+    public void testPessimisticUnderLoad() throws InterruptedException {
+        loadTest(pessimistic, "pessimistic");
+    }
+
+    @Test
+    @DisplayName("Optimistic: lost update because of data races")
+    @Tag("optimistic")
+    @Timeout(60)
+    public void lostUpdateOptimistic() throws InterruptedException {
+        shouldNotLoseUpdate(optimistic);
+    }
+
+    @Test
+    @DisplayName("Pessimistic: lost update because of data races")
+    @Tag("pessimistic")
+    @Timeout(60)
+    public void lostUpdatePessimistic() throws InterruptedException {
+        shouldNotLoseUpdate(pessimistic);
+    }
+
+    public void loadTest(Auction auction, String tag) throws InterruptedException {
+        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
+        CountDownLatch latch = new CountDownLatch(1);
+
+        BlockingQueue<Bid> bidQueue = new LinkedBlockingQueue<>(bidCount);
+        for (long i = 0; i < bidCount / 3; i++) {
+            bidQueue.offer(new Bid(i - 1, i - 1, i - 1));
+            bidQueue.offer(new Bid(i, i, i));
+            bidQueue.offer(new Bid(i + 1, i + 1, i + 1));
+        }
+        long expectedPrice = bidCount / 3;
+
+        for (int i = 0; i < poolSize; i++) {
+            executor.submit(() -> {
+                try {
+                    latch.await();
+                } catch (InterruptedException ignored) {}
+
+                for (int it = 0; it < iterations; it++) {
+                    Bid bid = bidQueue.poll();
+                    auction.propose(bid);
+                    if (it % 5 == 0) {
+                        auction.getLatestBid();
+                    }
+                }
+            });
+        }
+
+        long start = System.currentTimeMillis();
+        latch.countDown();
+        executor.shutdown();
+        executor.awaitTermination(20, TimeUnit.SECONDS);
+        long end = System.currentTimeMillis();
+
+        assertEquals(expectedPrice, auction.getLatestBid().getPrice());
+        stat.addData(tag, end - start);
+    }
+
+    public void shouldNotLoseUpdate(Auction auction) throws InterruptedException {
+        ExecutorService executor = Executors.newFixedThreadPool(2);
+
+        BlockingQueue<Bid> incBidQueue = new LinkedBlockingQueue<>();
+        LongStream.range(0, iterations*2).boxed().forEach(i -> incBidQueue.offer(new Bid(i, i, i)));
+
+        for (int i = 0; i < iterations; i++) {
+            CountDownLatch startAuctionTasksLatch = new CountDownLatch(1);
+            CountDownLatch auctionTasksDoneLatch = new CountDownLatch(2);
+            Bid bid1 = incBidQueue.poll();
+            Bid bid2 = incBidQueue.poll();
+
+            executor.submit(() -> {
+                try {
+                    startAuctionTasksLatch.await();
+                } catch (InterruptedException ignored) {}
+                auction.propose(bid1);
+                auctionTasksDoneLatch.countDown();
+            });
+            executor.submit(() -> {
+                try {
+                    startAuctionTasksLatch.await();
+                } catch (InterruptedException ignored) {}
+                auction.propose(bid2);
+                auctionTasksDoneLatch.countDown();
+            });
+            startAuctionTasksLatch.countDown();
+            auctionTasksDoneLatch.await();
+
+            Long latestPrice = auction.getLatestBid().getPrice();
+            Long expectedPrice = Math.max(bid1.getPrice(), bid2.getPrice());
+            assertEquals(expectedPrice, latestPrice, "Lost update found");
+        }
+
+        executor.shutdownNow();
+    }
+}
Index: src/test/java/course/concurrency/m3_shared/immutable/OrderServiceTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/course/concurrency/m3_shared/immutable/OrderServiceTests.java b/src/test/java/course/concurrency/m3_shared/immutable/OrderServiceTests.java
new file mode 100644
--- /dev/null	(date 1683572586000)
+++ b/src/test/java/course/concurrency/m3_shared/immutable/OrderServiceTests.java	(date 1683572586000)
@@ -0,0 +1,98 @@
+package course.concurrency.m3_shared.immutable;
+
+import org.junit.jupiter.api.RepeatedTest;
+import org.junit.jupiter.api.Test;
+
+import java.util.List;
+import java.util.concurrent.*;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class OrderServiceTests {
+
+    private OrderService service = new OrderService();
+
+    private List<Item> items = List.of(new Item(), new Item());
+
+    @Test
+    public void testDelivery() {
+        long orderId = service.createOrder(items);
+        service.setPacked(orderId);
+        service.updatePaymentInfo(orderId, new PaymentInfo());
+
+        boolean isDelivered = service.isDelivered(orderId);
+        assertTrue(isDelivered);
+    }
+
+    @Test
+    public void testDeliveryWithDuplicatePacking() {
+        long orderId = service.createOrder(items);
+        service.setPacked(orderId);
+        service.setPacked(orderId);
+        service.setPacked(orderId);
+        service.updatePaymentInfo(orderId, new PaymentInfo());
+
+        boolean isDelivered = service.isDelivered(orderId);
+        assertTrue(isDelivered);
+    }
+
+    @Test
+    public void testPartialCompleteWithDelivery() {
+        long orderId = service.createOrder(items);
+        service.updatePaymentInfo(orderId, new PaymentInfo());
+
+        boolean isDelivered = service.isDelivered(orderId);
+        assertFalse(isDelivered);
+    }
+
+    @Test
+    public void testPartialCompleteWithPacking() {
+        long orderId = service.createOrder(items);
+        service.setPacked(orderId);
+
+        boolean isDelivered = service.isDelivered(orderId);
+        assertFalse(isDelivered);
+    }
+
+    @Test
+    public void testPartialCompleteWith2Packing() {
+        long orderId = service.createOrder(items);
+        service.setPacked(orderId);
+        service.setPacked(orderId);
+
+        boolean isDelivered = service.isDelivered(orderId);
+        assertFalse(isDelivered);
+    }
+
+    @RepeatedTest(5)
+    public void testWithManyThreads() throws InterruptedException {
+        int iterations = 10_000;
+        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
+
+        BlockingQueue<Long> orderToPack = new ArrayBlockingQueue<>(iterations*3);
+        BlockingQueue<Long> orderToPay = new ArrayBlockingQueue<>(iterations);
+        BlockingQueue<Long> orderIdLog = new ArrayBlockingQueue<>(iterations);
+
+        for(int i = 0; i< iterations; ++i) {
+            Long id = service.createOrder(items);
+                        orderToPack.offer(id);
+                        orderToPay.offer(id);
+                        orderIdLog.offer(id);
+        }
+
+        for(int i = 0; i< iterations; ++i) {
+            executor.submit(() -> service.setPacked(orderToPack.poll()));
+            executor.submit(() -> service.updatePaymentInfo(orderToPay.poll(), new PaymentInfo()));
+        }
+
+        executor.shutdown();
+        executor.awaitTermination(1, TimeUnit.MINUTES);
+
+        do {
+            long orderId = orderIdLog.take();
+            boolean isDelivered = service.isDelivered(orderId);
+            assertTrue(isDelivered, String.format("Order %d is not completed", orderId));
+        } while (!orderIdLog.isEmpty());
+    }
+}
Index: src/test/java/course/concurrency/m3_shared/collections/RestaurantServiceTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/course/concurrency/m3_shared/collections/RestaurantServiceTests.java b/src/test/java/course/concurrency/m3_shared/collections/RestaurantServiceTests.java
new file mode 100644
--- /dev/null	(date 1691402714140)
+++ b/src/test/java/course/concurrency/m3_shared/collections/RestaurantServiceTests.java	(date 1691402714140)
@@ -0,0 +1,72 @@
+package course.concurrency.m3_shared.collections;
+
+import course.concurrency.exams.auction.ExecutionStatistics;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.RepeatedTest;
+
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class RestaurantServiceTests {
+
+    private static final int TEST_COUNT = 10;
+    private static final ExecutionStatistics stat = new ExecutionStatistics();
+
+    private static final int iterations = 1_000_000;
+    private static final int poolSize = Runtime.getRuntime().availableProcessors()*2;
+
+    private ExecutorService executor;
+    private RestaurantService service;
+
+    @BeforeEach
+    public void setup() {
+        executor = Executors.newFixedThreadPool(poolSize);
+        service = new RestaurantService();
+    }
+
+    @AfterAll
+    public static void printStat() {
+        stat.printStatistics();
+    }
+
+    @RepeatedTest(TEST_COUNT)
+    public void test() throws InterruptedException {
+        CountDownLatch latch = new CountDownLatch(1);
+
+        for (int i = 0; i < poolSize; i++) {
+            executor.submit(() -> {
+                try {
+                    latch.await();
+                } catch (InterruptedException ignored) {}
+
+                for (int it = 0; it < iterations; it++) {
+                    service.getByName("A");
+                    service.getByName("B");
+                    service.getByName("C");
+                }
+            });
+        }
+
+        long start = System.currentTimeMillis();
+        latch.countDown();
+        executor.shutdown();
+        executor.awaitTermination(30, TimeUnit.SECONDS);
+        long end = System.currentTimeMillis();
+
+        Set<String> statResult = service.printStat();
+
+        assertEquals(3, statResult.size());
+        assertTrue(statResult.contains("A - " + iterations*poolSize));
+        assertTrue(statResult.contains("B - " + iterations*poolSize));
+        assertTrue(statResult.contains("C - " + iterations*poolSize));
+
+        stat.addData("service",end - start);
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/PingPong.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/PingPong.java b/src/main/java/course/concurrency/m3_shared/PingPong.java
new file mode 100644
--- /dev/null	(date 1695134326959)
+++ b/src/main/java/course/concurrency/m3_shared/PingPong.java	(date 1695134326959)
@@ -0,0 +1,19 @@
+package course.concurrency.m3_shared;
+
+public class PingPong {
+
+    public static void ping() {
+
+    }
+
+    public static void pong() {
+
+    }
+
+    public static void main(String[] args) {
+        Thread t1 = new Thread(() -> ping());
+        Thread t2 = new Thread(() -> pong());
+        t1.start();
+        t2.start();
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/immutable/Order.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/immutable/Order.java b/src/main/java/course/concurrency/m3_shared/immutable/Order.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/immutable/Order.java	(date 1681219100000)
@@ -0,0 +1,66 @@
+package course.concurrency.m3_shared.immutable;
+
+import java.util.List;
+
+import static course.concurrency.m3_shared.immutable.Order.Status.NEW;
+
+public class Order {
+
+    public enum Status { NEW, IN_PROGRESS, DELIVERED }
+
+    private Long id;
+    private List<Item> items;
+    private PaymentInfo paymentInfo;
+    private boolean isPacked;
+    private Status status;
+
+    public Order(List<Item> items) {
+        this.items = items;
+        this.status = NEW;
+    }
+
+    public synchronized boolean checkStatus() {
+        if (items != null && !items.isEmpty() && paymentInfo != null && isPacked) {
+            return true;
+        }
+        return false;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public List<Item> getItems() {
+        return items;
+    }
+
+    public PaymentInfo getPaymentInfo() {
+        return paymentInfo;
+    }
+
+    public void setPaymentInfo(PaymentInfo paymentInfo) {
+        this.paymentInfo = paymentInfo;
+        this.status = Status.IN_PROGRESS;
+    }
+
+    public boolean isPacked() {
+        return isPacked;
+    }
+
+    public void setPacked(boolean packed) {
+        isPacked = packed;
+        this.status = Status.IN_PROGRESS;
+    }
+
+    public Status getStatus() {
+        return status;
+    }
+
+    public void setStatus(Status status) {
+        this.status = status;
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/immutable/Item.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/immutable/Item.java b/src/main/java/course/concurrency/m3_shared/immutable/Item.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/immutable/Item.java	(date 1681219100000)
@@ -0,0 +1,4 @@
+package course.concurrency.m3_shared.immutable;
+
+public class Item {
+}
Index: src/main/java/course/concurrency/m3_shared/immutable/OrderService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/immutable/OrderService.java b/src/main/java/course/concurrency/m3_shared/immutable/OrderService.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/immutable/OrderService.java	(date 1681219100000)
@@ -0,0 +1,46 @@
+package course.concurrency.m3_shared.immutable;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class OrderService {
+
+    private Map<Long, Order> currentOrders = new HashMap<>();
+    private long nextId = 0L;
+
+    private synchronized long nextId() {
+        return nextId++;
+    }
+
+    public synchronized long createOrder(List<Item> items) {
+        long id = nextId();
+        Order order = new Order(items);
+        order.setId(id);
+        currentOrders.put(id, order);
+        return id;
+    }
+
+    public synchronized void updatePaymentInfo(long orderId, PaymentInfo paymentInfo) {
+        currentOrders.get(orderId).setPaymentInfo(paymentInfo);
+        if (currentOrders.get(orderId).checkStatus()) {
+            deliver(currentOrders.get(orderId));
+        }
+    }
+
+    public synchronized void setPacked(long orderId) {
+        currentOrders.get(orderId).setPacked(true);
+        if (currentOrders.get(orderId).checkStatus()) {
+            deliver(currentOrders.get(orderId));
+        }
+    }
+
+    private synchronized void deliver(Order order) {
+        /* ... */
+        currentOrders.get(order.getId()).setStatus(Order.Status.DELIVERED);
+    }
+
+    public synchronized boolean isDelivered(long orderId) {
+        return currentOrders.get(orderId).getStatus().equals(Order.Status.DELIVERED);
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/benchmarks/CounterBenchmarks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/benchmarks/CounterBenchmarks.java b/src/main/java/course/concurrency/m3_shared/benchmarks/CounterBenchmarks.java
new file mode 100644
--- /dev/null	(date 1692443420236)
+++ b/src/main/java/course/concurrency/m3_shared/benchmarks/CounterBenchmarks.java	(date 1692443420236)
@@ -0,0 +1,365 @@
+package course.concurrency.m3_shared.benchmarks;
+
+import org.openjdk.jmh.annotations.*;
+import org.openjdk.jmh.runner.Runner;
+import org.openjdk.jmh.runner.RunnerException;
+import org.openjdk.jmh.runner.options.Options;
+import org.openjdk.jmh.runner.options.OptionsBuilder;
+
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.LongAdder;
+import java.util.concurrent.locks.*;
+
+@State(Scope.Benchmark)
+@BenchmarkMode(Mode.Throughput)
+@OutputTimeUnit(TimeUnit.MILLISECONDS)
+public class CounterBenchmarks {
+
+    // Change WRITERS and READERS to experiment
+    public static final int WRITERS = 7;
+    public static final int READERS = 1;
+
+    private final AtomicLong atomicLongCounter = new AtomicLong();
+    private final LongAdder longAdderCounter = new LongAdder();
+
+    private final AtomicLong atomic = new AtomicLong();
+
+    private final Lock lock = new ReentrantLock();
+    private final Lock lockFair = new ReentrantLock(true);
+
+    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+    private final ReadWriteLock readWriteLockFair = new ReentrantReadWriteLock(true);
+
+    private final Semaphore semaphore = new Semaphore(1);
+    private final Semaphore semaphoreFair = new Semaphore(1, true);
+
+    private final StampedLock stampedLock = new StampedLock();
+
+    private long value;
+    private volatile long volatileValue;
+    private long newValue;
+    private long tmp = 0;
+
+    @Setup
+    public void setup() {
+        tmp++;
+        value = tmp;
+        volatileValue = tmp;
+        newValue = tmp+5;
+        atomic.set(value);
+    }
+
+    public static void main(String[] args) throws RunnerException {
+        Options options = new OptionsBuilder()
+                .include(CounterBenchmarks.class.getName())
+                .forks(1)
+//                .resultFormat(ResultFormatType.JSON)
+//                .result("benchmark-result.json")
+                .build();
+
+        new Runner(options).run();
+    }
+
+    @Benchmark
+    @Group("AtomicLong_counter")
+    @GroupThreads(WRITERS)
+    public long writeAtomicLong() {
+        return atomicLongCounter.incrementAndGet();
+    }
+
+    @Benchmark
+    @Group("AtomicLong_counter")
+    @GroupThreads(READERS)
+    public long readAtomicLong() {
+        return atomicLongCounter.get();
+    }
+
+    @Benchmark
+    @Group("LongAdder_counter")
+    @GroupThreads(WRITERS)
+    public void writeLongAdder() {
+        longAdderCounter.increment();
+    }
+
+    @Benchmark
+    @Group("LongAdder_counter")
+    @GroupThreads(READERS)
+    public long readLongAdder() {
+        return longAdderCounter.sum();
+    }
+
+    @Benchmark
+    @Group("ReentrantLock")
+    @GroupThreads(WRITERS)
+    public void writeReentrantLock() {
+        try {
+            lock.lock();
+            value++;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReentrantLock")
+    @GroupThreads(READERS)
+    public long readReentrantLock() {
+        try {
+            lock.lock();
+            return value;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReentrantLock_fair")
+    @GroupThreads(WRITERS)
+    public void writeReentrantLockFair() {
+        try {
+            lockFair.lock();
+            value++;
+        } finally {
+            lockFair.unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReentrantLock_fair")
+    @GroupThreads(READERS)
+    public long readReentrantLockFair() {
+        try {
+            lockFair.lock();
+            return value;
+        } finally {
+            lockFair.unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReadWriteLock")
+    @GroupThreads(WRITERS)
+    public void writeReadWriteLock() {
+        try {
+            readWriteLock.writeLock().lock();
+            value++;
+        } finally {
+            readWriteLock.writeLock().unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReadWriteLock")
+    @GroupThreads(READERS)
+    public long readReadWriteLock() {
+        try {
+            readWriteLock.readLock().lock();
+            return value;
+        } finally {
+            readWriteLock.readLock().unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReadWriteLock_fair")
+    @GroupThreads(WRITERS)
+    public void writeReadWriteLockFair() {
+        try {
+            readWriteLockFair.writeLock().lock();
+            value++;
+        } finally {
+            readWriteLockFair.writeLock().unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("ReadWriteLock_fair")
+    @GroupThreads(READERS)
+    public long readReadWriteLockFair() {
+        try {
+            readWriteLockFair.readLock().lock();
+            return value;
+        } finally {
+            readWriteLockFair.readLock().unlock();
+        }
+    }
+
+    @Benchmark
+    @Group("Semaphore")
+    @GroupThreads(WRITERS)
+    public void writeSemaphore() throws InterruptedException {
+        try {
+            semaphore.acquire();
+            value++;
+        } finally {
+            semaphore.release();
+        }
+    }
+
+    @Benchmark
+    @Group("Semaphore")
+    @GroupThreads(READERS)
+    public long readSemaphore() throws InterruptedException {
+        try {
+            semaphore.acquire();
+            return value;
+        } finally {
+            semaphore.release();
+        }
+    }
+
+    @Benchmark
+    @Group("Semaphore_fair")
+    @GroupThreads(WRITERS)
+    public void writeSemaphoreFair() throws InterruptedException {
+        try {
+            semaphoreFair.acquire();
+            value++;
+        } finally {
+            semaphoreFair.release();
+        }
+    }
+
+    @Benchmark
+    @Group("Semaphore_fair")
+    @GroupThreads(READERS)
+    public long readSemaphoreFair() throws InterruptedException {
+        try {
+            semaphoreFair.acquire();
+            return value;
+        } finally {
+            semaphoreFair.release();
+        }
+    }
+
+    @Benchmark
+    @Group("StampedLock_readwrite")
+    @GroupThreads(WRITERS)
+    public void writeStampedLockRW() {
+        long stamp = stampedLock.writeLock();
+        try {
+            value++;
+        } finally {
+            stampedLock.unlock(stamp);
+        }
+    }
+
+    @Benchmark
+    @Group("StampedLock_readwrite")
+    @GroupThreads(READERS)
+    public long readStampedLockRW() {
+        long stamp = stampedLock.readLock();
+        try {
+            return value;
+        } finally {
+            stampedLock.unlockRead(stamp);
+        }
+    }
+
+    @Benchmark
+    @Group("StampedLock_optimistic")
+    @GroupThreads(WRITERS)
+    public void writeStampedLockOptimistic() {
+        long stamp = stampedLock.writeLock();
+        try {
+            value++;
+        } finally {
+            stampedLock.unlock(stamp);
+        }
+    }
+
+    @Benchmark
+    @Group("StampedLock_optimistic")
+    @GroupThreads(READERS)
+    public long readStampedLockOptimistic() {
+        long stamp;
+        do {
+            stamp = stampedLock.tryOptimisticRead();
+            value = newValue;
+        } while (!stampedLock.validate(stamp));
+        return value;
+    }
+
+    @Benchmark
+    @Group("synchronized")
+    @GroupThreads(WRITERS)
+    public void writeSynchronized() {
+        synchronized (this) {
+            value++;
+        }
+    }
+
+    @Benchmark
+    @Group("synchronized")
+    @GroupThreads(READERS)
+    public long readSynchronized() {
+        synchronized (this) {
+            return value;
+        }
+    }
+
+    @Benchmark
+    @Group("volatile_synchronized")
+    @GroupThreads(WRITERS)
+    public void writeSynchronizedVolatile() {
+        synchronized (this) {
+            volatileValue++;
+        }
+    }
+
+    @Benchmark
+    @Group("volatile_synchronized")
+    @GroupThreads(READERS)
+    public long readSynchronizedVolatile() {
+        return volatileValue;
+    }
+
+    @Benchmark
+    @Group("volatile")
+    @GroupThreads(WRITERS)
+    public void writeVolatile() {
+        volatileValue = newValue;
+    }
+
+    @Benchmark
+    @Group("volatile")
+    @GroupThreads(READERS)
+    public long readVolatile() {
+        return volatileValue;
+    }
+
+    @Benchmark
+    @Group("Atomic")
+    @GroupThreads(READERS)
+    public long readAtomic() {
+        return atomic.get();
+    }
+
+    @Benchmark
+    @Group("Atomic")
+    @GroupThreads(WRITERS)
+    public void writeAtomic() {
+        atomic.set(newValue);
+    }
+
+    @Benchmark
+    @Group("Atomic_optimistic")
+    @GroupThreads(WRITERS)
+    public long updateOptimistic() {
+        long previous, tmp;
+        do {
+            previous = atomic.get();
+            tmp = previous + newValue;
+        } while (!atomic.compareAndSet(previous, tmp));
+        return newValue;
+    }
+
+    @Benchmark
+    @Group("Atomic_accumulate")
+    @GroupThreads(WRITERS)
+    public long updateAtomicMethods() {
+        return atomic.accumulateAndGet(newValue, (x1, x2) -> x1 + x2);
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/immutable/PaymentInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/immutable/PaymentInfo.java b/src/main/java/course/concurrency/m3_shared/immutable/PaymentInfo.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/immutable/PaymentInfo.java	(date 1681219100000)
@@ -0,0 +1,4 @@
+package course.concurrency.m3_shared.immutable;
+
+public class PaymentInfo {
+}
Index: src/main/java/course/concurrency/m3_shared/collections/RestaurantService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/collections/RestaurantService.java b/src/main/java/course/concurrency/m3_shared/collections/RestaurantService.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/collections/RestaurantService.java	(date 1681219100000)
@@ -0,0 +1,31 @@
+package course.concurrency.m3_shared.collections;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class RestaurantService {
+
+    private Map<String, Restaurant> restaurantMap = new ConcurrentHashMap<>() {{
+        put("A", new Restaurant("A"));
+        put("B", new Restaurant("B"));
+        put("C", new Restaurant("C"));
+    }};
+
+    private Object stat;
+
+    public Restaurant getByName(String restaurantName) {
+        addToStat(restaurantName);
+        return restaurantMap.get(restaurantName);
+    }
+
+    public void addToStat(String restaurantName) {
+        // your code
+    }
+
+    public Set<String> printStat() {
+        // your code
+        return new HashSet<>();
+    }
+}
Index: src/main/java/course/concurrency/m3_shared/collections/Restaurant.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/m3_shared/collections/Restaurant.java b/src/main/java/course/concurrency/m3_shared/collections/Restaurant.java
new file mode 100644
--- /dev/null	(date 1681219100000)
+++ b/src/main/java/course/concurrency/m3_shared/collections/Restaurant.java	(date 1681219100000)
@@ -0,0 +1,12 @@
+package course.concurrency.m3_shared.collections;
+
+public class Restaurant {
+    private String name;
+    public Restaurant(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+}
